Here are some guidelines for writing comments in code to ensure clarity and understanding of functions and their usage:

1. **Explain the Purpose of the Function**: 
   Start with a concise summary of what the function does. Avoid repeating the function name in the comment. Use clear and concise language without jargon unless it's widely understood.

2. **Describe the Arguments the Function Takes**: 
   List the parameters (arguments) the function expects and their data types. Explain what each argument represents and how it's used within the function.

3. **Explain What the Function Returns**: 
   Describe the data type and format of the value the function returns. If the function doesn't return a value, mention it explicitly (e.g., "This function performs an action and does not return a value").

4. **Add Comments for Complex Logic or Edge Cases**: 
   If the function involves complex logic or error handling, include comments to explain those sections for better understanding. Mention any edge cases the function might encounter and how it handles them.

5. **Use Code Formatting Consistently**: 
   Maintain consistent formatting for comments throughout your codebase. This improves readability for both humans and AI agents.

6. **Follow Coding Style Guides**: 
   Adhere to the established coding conventions and style guides for your programming language or project.

7. **Consider Including Examples**: 
   When appropriate, add code examples demonstrating how to use the function with different inputs. This can be particularly helpful for AI agents that learn by example. Here's an example following these guidelines:

```python
  def calculate_area(length: float, width: float) -> float:
      """Calculates the area of a rectangle.

      Args:
          length (float): The length of the rectangle.
          width (float): The width of the rectangle.

      Returns:
          float: The area of the rectangle (length x width).
      """
      return length * width  # Function body to calculate area
```

# Commenting Guidelines Examples

## Primary Objectives

### Code Segmentation:

- Divide code into logical sections based on functionality or purpose.
- Add descriptive headers to mark these sections, explaining their role in the program.

### Detailed Commenting:

- Provide line-by-line or block-level comments to explain the logic and functionality of the code.
- Clarify complex logic, algorithms, or operations to make the code accessible to various expertise levels.

### Enhancing Learning Value:

- Highlight alternative approaches or justify the chosen methods where applicable.
- Point out best practices and potential pitfalls to encourage good programming habits.

### General Formatting Improvements:

- Use consistent formatting and indentation for readability.
- Clearly label sections like variable declarations, function definitions, loops, conditions, and outputs.

## Comment Formatting Examples

### File-Level Overview
```solidity
/// @title   Example DeFi Strategy Manager
/// @author  Example
/// @notice  Manages token strategies and yield generation.
/// @dev     Contains mock integrations for demonstration purposes.
```

### Section Dividers
```
/************************************************/
/*************** VARIABLE DECLARATIONS **********/
/************************************************/
```

### Detailed Function Comments
```solidity
/// @notice   Deposits tokens into a strategy and begins yield generation.
/// @dev      Tracks user deposits and updates internal records.
/// @param    user The address of the user making the deposit.
/// @param    amount The amount of tokens to deposit.
/// @return   strategyId The ID of the strategy created for the user.
function depositTokens(address user, uint256 amount) external returns (uint256) {
    // Verify the user has sufficient balance
    require(balanceOf(user) >= amount, "Insufficient balance.");

    // Transfer tokens to the contract
    _transfer(user, address(this), amount);

    // Create a new strategy and return its ID
    uint256 strategyId = _createStrategy(user, amount);
    
    return strategyId;
}
```

### Block-Level Comments
```solidity
// Ensure the user has an active strategy
require(strategyId > 0, "No active strategy found.");

// Calculate accrued rewards since the last update
uint256 rewards = _calculateRewards(user, strategyId);

// Update user's strategy with the new rewards
_updateStrategy(user, strategyId, rewards);
```

### Complex Logic Explanation
```solidity
// The following loop applies accrued rewards to all active strategies.
// It calculates the new balance for each strategy using the formula:
// newBalance = currentBalance + (currentBalance * rewardRate * timeElapsed)
for (uint256 i = 0; i < activeStrategies.length; i++) {
    Strategy storage strategy = activeStrategies[i];
    uint256 timeElapsed = block.timestamp - strategy.lastUpdated;
    uint256 rewards = strategy.balance * strategy.rewardRate * timeElapsed / 1e18;
    strategy.balance += rewards;
    strategy.lastUpdated = block.timestamp;
}
```

# Best Practices for Comments

- **Consistency**: Use a uniform style for headers, inline comments, and block comments.
- **Clarity**: Use simple language that avoids jargon unless necessary.
- **Relevance**: Only comment on non-obvious parts of the code; avoid stating the obvious.
  - Good: `// Ensure the user is authorized before proceeding`
  - Bad: `// Call the depositTokens function`
- **Tone**: Use an instructional and friendly tone, focusing on helping others understand.
- **Avoid Overloading**: Keep comments concise but sufficient to explain the intent and functionality.

## Sample Code with Full Comments

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/// @title   Example Token Strategy Manager
/// @author  Example
/// @notice  Manages deposits and yield strategies for users.
/// @dev     Demonstrates best practices in commenting.

contract TokenStrategyManager {
    
    /************************************************/
    /************** STATE VARIABLES *****************/
    /************************************************/

    uint256 private nextStrategyId; // Tracks the next strategy ID to assign
    mapping(address => uint256) public userBalances; // Maps user addresses to their balances

    /************************************************/
    /****************** EVENTS **********************/
    /************************************************/

    /// @notice Emitted when a new strategy is created.
    event StrategyCreated(address indexed user, uint256 indexed strategyId);

    /************************************************/
    /*************** PUBLIC FUNCTIONS ***************/
    /************************************************/

    /// @notice Deposits tokens for a user and creates a strategy.
    /// @param  user The address of the user depositing tokens.
    /// @param  amount The number of tokens being deposited.
    function depositTokens(address user, uint256 amount) external {
        // Increment the user's balance
        userBalances[user] += amount;

        // Create a new strategy for the user
        uint256 strategyId = _createStrategy(user, amount);

        // Emit an event for the new strategy
        emit StrategyCreated(user, strategyId);
    }

    /************************************************/
    /****************** INTERNAL ********************/
    /************************************************/

    /// @notice Internal function to create a strategy.
    /// @param user The address of the user.
    /// @param amount The amount to allocate to the strategy.
    /// @return strategyId The ID of the created strategy.
    function _createStrategy(address user, uint256 amount) internal returns (uint256) {
        // Assign the next available strategy ID
        uint256 strategyId = nextStrategyId++;

        // Logic to initialize the strategy
        // (e.g., store in a mapping or array)

        return strategyId;
    }
}


By following these guidelines, you can write comments that are informative for both human developers and AI agents, making it easier to understand, use, and maintain your code.